
**გადაიტანეთ ლექციაში განხილული API თქვენთან(დამოუკიდებლად დაწერეთ თავიდან) და დაამატეთ შემდეგი ფუნცქიონალები:**

1. გააკეთეთ იგივე Refactoring იუზერებისთვის რაც ლექციაში პროდუქტებისთვის გავაკეთეთ.

2. გაწერეთ ლოგიკა იუზერების კონტროლერებში(CRUD ოპერაციები)

3. შექმენით Middleware რომელიც დალოგავს API-ში შემოსული ყველა რექვესთის მეთოდს, URL-ს და ზუსტ დროს როდესაც ეს რექვესთი შემოვიდა

4. შექმენით Middleware რომელიც ამოქმედდება მხოლოდ პროდუქტების როუტებზე რექვესთის გაგზავნისას. კერძოდ მაშინ როცა ახალი პროდუქტი ემატება. Middleware-ის ლოგიკის მიხედვით პროდუქტებს ემატება ახალი ველი "slug" რომელიც პროდუქტის სახელს slug-ად აქცევს. მაგალითად Macbook Pro => macbook-pro.(გაიხსენეთ ბიბლიოთეკა slugify. ასევე, ჩვენ არ გაგვიკეთებია რექვესთის body-ს შეცვლა middleware-დან, მაგრამ მარტივია და თქვენი იმედი მაქვს :) )

5. შექმენით გარემოს ცვლადი სახელად PORT(config.env-ში) სადაც port-ის ნომერს შეინახავთ და server-ის მოსასმენად ამ გარემოს ცვლადს გამოიყენებთ.

6. შექმენით გარემოს ცვლადი სახელად isMaintenance. თუკი ის true-ს ტოლი იქნება მაშინ Middleware-ის საშუალებით ყველა როუტზე რექვესთის გაგზავნისას უნდა დააბრუნოთ შემდეგი რესპონზი: '{ message: "Site is under maintenance" }'

7(ბონუსი). შექმენით Middleware რომელიც აკრძალავს წუთში 10 რექვესთზე მეტის მიღებას კლიენტისგან. გამოიყენეთ [express-rate-limit](https://www.npmjs.com/package/express-rate-limit) ბიბლიოთეკა